@startuml API_Integration_Sequence_Diagram
!theme aws-orange
title Data Research Analysis Platform - API Integration with Authentication

participant "Frontend\n(Vue/Nuxt)" as Frontend
participant "Auth Middleware" as AuthMiddleware
participant "Express Router" as Router
participant "Processor" as Processor
participant "Database\n(PostgreSQL)" as Database
participant "External Services" as External

== Authentication Flow ==

Frontend -> Router: POST /api/auth/login
activate Router

Router -> Processor: UserProcessor.login(credentials)
activate Processor

Processor -> Database: Find user by email
activate Database
Database --> Processor: User record
deactivate Database

Processor -> Processor: Compare password hash
Processor -> Processor: Generate JWT token

Processor --> Router: { token, user, expires }
deactivate Processor

Router --> Frontend: HTTP 200 OK + JWT token
deactivate Router

Frontend -> Frontend: Store token in localStorage
Frontend -> Frontend: Update authentication state

== Authenticated API Request ==

Frontend -> Router: GET /api/projects\nAuthorization: Bearer {JWT}
activate Router

Router -> AuthMiddleware: Validate JWT token
activate AuthMiddleware

AuthMiddleware -> AuthMiddleware: Verify token signature
AuthMiddleware -> AuthMiddleware: Check expiration

alt Token Valid
    AuthMiddleware -> Database: Verify user exists
    activate Database
    Database --> AuthMiddleware: User confirmed
    deactivate Database
    
    AuthMiddleware --> Router: User context attached
    deactivate AuthMiddleware
    
    Router -> Processor: ProjectProcessor.getUserProjects(userId)
    activate Processor
    
    Processor -> Database: SELECT projects WHERE user_id = ?
    activate Database
    Database --> Processor: Project records
    deactivate Database
    
    Processor --> Router: Projects array
    deactivate Processor
    
    Router --> Frontend: HTTP 200 OK + projects data
    
else Token Invalid/Expired
    AuthMiddleware --> Router: HTTP 401 Unauthorized
    deactivate AuthMiddleware
    
    Router --> Frontend: HTTP 401 Unauthorized
    
    Frontend -> Frontend: Clear stored token
    Frontend -> Frontend: Redirect to login page
end

deactivate Router

== Data Source Creation ==

Frontend -> Router: POST /api/data-sources\nAuthorization: Bearer {JWT}\nContent-Type: application/json
activate Router

Router -> AuthMiddleware: Validate JWT
activate AuthMiddleware
AuthMiddleware --> Router: User authenticated
deactivate AuthMiddleware

Router -> Processor: DataSourceProcessor.create(dataSourceData)
activate Processor

Processor -> Processor: Validate data source configuration
Processor -> External: Test database connection
activate External

alt Connection Successful
    External --> Processor: Connection confirmed
    deactivate External
    
    Processor -> Database: BEGIN TRANSACTION
    activate Database
    
    Processor -> Database: INSERT INTO dra_data_sources
    Database --> Processor: Data source created
    
    Processor -> Database: COMMIT TRANSACTION
    deactivate Database
    
    Processor --> Router: Created data source
    deactivate Processor
    
    Router --> Frontend: HTTP 201 Created + data source
    
else Connection Failed
    External --> Processor: Connection error
    deactivate External
    
    Processor --> Router: Validation error
    deactivate Processor
    
    Router --> Frontend: HTTP 400 Bad Request + error details
end

deactivate Router

== File Upload with Progress ==

Frontend -> Router: POST /api/data-sources/pdf\nAuthorization: Bearer {JWT}\nContent-Type: multipart/form-data
activate Router

Router -> AuthMiddleware: Validate JWT
activate AuthMiddleware
AuthMiddleware --> Router: User authenticated
deactivate AuthMiddleware

Router -> Router: Multer middleware processes file
Router -> Processor: PDFProcessor.handleUpload(file)
activate Processor

Processor -> Database: INSERT INTO dra_data_sources
activate Database
Database --> Processor: Data source record created
deactivate Database

Processor -> External: Queue background processing job
activate External
External --> Processor: Job queued successfully
deactivate External

Processor --> Router: Upload successful
deactivate Processor

Router --> Frontend: HTTP 200 OK + job details
deactivate Router

note right: Background processing continues\nvia Socket.IO (see previous diagram)

== Dashboard Export ==

Frontend -> Router: POST /api/dashboards/{id}/export\nAuthorization: Bearer {JWT}
activate Router

Router -> AuthMiddleware: Validate JWT + ownership
activate AuthMiddleware

AuthMiddleware -> Database: Verify dashboard ownership
activate Database
Database --> AuthMiddleware: User owns dashboard
deactivate Database

AuthMiddleware --> Router: Access granted
deactivate AuthMiddleware

Router -> Processor: DashboardProcessor.export(dashboardId, format)
activate Processor

Processor -> Database: Fetch dashboard data
activate Database
Database --> Processor: Dashboard configuration
deactivate Database

Processor -> External: Generate export file
activate External
External --> Processor: Export file created
deactivate External

Processor -> Database: INSERT INTO dra_dashboard_export_metadata
activate Database
Database --> Processor: Export metadata saved
deactivate Database

Processor --> Router: Export initiated
deactivate Processor

Router --> Frontend: HTTP 202 Accepted + export job ID
deactivate Router

note right: Export completion notified\nvia Socket.IO

== Data Source Row/Column Manipulation ==

Frontend -> Router: POST /api/data-source/add-row\nAuthorization: Bearer {JWT}
activate Router

Router -> AuthMiddleware: Validate JWT token
activate AuthMiddleware
AuthMiddleware -> Database: Verify user and data source access
Database --> AuthMiddleware: Access granted
AuthMiddleware -> Router: User authenticated
deactivate AuthMiddleware

Router -> Processor: DataSourceProcessor.addRowToDataSource(dataSourceId, rowData)
activate Processor

Processor -> Database: BEGIN TRANSACTION
Processor -> Database: INSERT INTO dynamic_table VALUES (...)
Database --> Processor: Row inserted with ID
Processor -> Database: UPDATE metadata SET row_count = row_count + 1
Database --> Processor: Metadata updated
Processor -> Database: COMMIT

Processor --> Router: { success: true, rowId, updatedCount }
deactivate Processor

Router --> Frontend: HTTP 200 OK + row data
deactivate Router

Frontend -> Frontend: Update local state with new row
Frontend -> Frontend: Refresh CustomDataTable component

== Column Addition ==

Frontend -> Router: POST /api/data-source/add-column\nAuthorization: Bearer {JWT}
activate Router

Router -> AuthMiddleware: Validate JWT and permissions
AuthMiddleware --> Router: Authorization confirmed

Router -> Processor: DataSourceProcessor.addColumnToDataSource(dataSourceId, columnConfig)
activate Processor

Processor -> Database: BEGIN TRANSACTION
Processor -> Database: ALTER TABLE dynamic_table ADD COLUMN column_name TYPE
Database --> Processor: Column added
Processor -> Database: UPDATE all rows SET column_name = default_value
Database --> Processor: Default values populated
Processor -> Database: UPDATE metadata SET column_count = column_count + 1
Database --> Processor: Metadata updated
Processor -> Database: COMMIT

Processor --> Router: { success: true, columnId, schema }
deactivate Processor

Router --> Frontend: HTTP 200 OK + column schema
deactivate Router

Frontend -> Frontend: Update local column definitions
Frontend -> Frontend: Refresh table structure

== Row Removal ==

Frontend -> Router: DELETE /api/data-source/row/{rowId}\nAuthorization: Bearer {JWT}
Router -> AuthMiddleware: Validate access
Router -> Processor: DataSourceProcessor.removeRowFromDataSource(dataSourceId, rowId)
Processor -> Database: DELETE FROM dynamic_table WHERE id = rowId
Processor -> Database: UPDATE metadata SET row_count = row_count - 1
Processor --> Router: { success: true, remainingCount }
Router --> Frontend: HTTP 200 OK

== Column Removal ==

Frontend -> Router: DELETE /api/data-source/column/{columnName}\nAuthorization: Bearer {JWT}
Router -> AuthMiddleware: Validate access
Router -> Processor: DataSourceProcessor.removeColumnFromDataSource(dataSourceId, columnName)
Processor -> Database: ALTER TABLE dynamic_table DROP COLUMN column_name
Processor -> Database: UPDATE metadata SET column_count = column_count - 1
Processor --> Router: { success: true, updatedSchema }
Router --> Frontend: HTTP 200 OK

== Schema Validation ==

Frontend -> Router: GET /api/data-source/{id}/schema\nAuthorization: Bearer {JWT}
Router -> AuthMiddleware: Validate access
Router -> Processor: DataSourceProcessor.getDataSourceSchema(dataSourceId)
Processor -> Database: DESCRIBE dynamic_table
Database --> Processor: Column definitions and constraints
Processor --> Router: { columns, constraints, metadata }
Router --> Frontend: HTTP 200 OK + schema

== Error Handling Patterns ==

alt Network Error
    Frontend -> Router: API Request times out
    Frontend -> Frontend: Show "Connection error" message
    Frontend -> Frontend: Retry mechanism with exponential backoff
    
else Server Error (500)
    Router -> Processor: Business logic error
    Processor -> Database: Database operation fails
    Database --> Processor: SQL error
    Processor --> Router: Internal error
    Router --> Frontend: HTTP 500 Internal Server Error
    Frontend -> Frontend: Show generic error message
    Frontend -> Frontend: Log error for debugging
    
else Validation Error (400)
    Router -> Processor: Invalid input data
    Processor -> Processor: Validation fails
    Processor --> Router: Validation errors array
    Router --> Frontend: HTTP 400 Bad Request + validation details
    Frontend -> Frontend: Highlight invalid form fields
    Frontend -> Frontend: Show specific error messages
    
else Authorization Error (403)
    Router -> AuthMiddleware: Check resource permissions
    AuthMiddleware -> Database: Verify ownership/permissions
    Database --> AuthMiddleware: Access denied
    AuthMiddleware --> Router: Forbidden
    Router --> Frontend: HTTP 403 Forbidden
    Frontend -> Frontend: Show "Access denied" message
end

== Rate Limiting ==

Frontend -> Router: Multiple rapid requests
Router -> Router: Check rate limit (requests/minute)

alt Rate Limit Exceeded
    Router --> Frontend: HTTP 429 Too Many Requests
    note right: Retry-After header included
    Frontend -> Frontend: Show rate limit message
    Frontend -> Frontend: Implement request queuing
    
else Within Limits
    Router -> AuthMiddleware: Continue processing
    note right: Normal API flow continues
end

== Project Deletion with Cascade ==

Frontend -> Router: DELETE /api/project/{projectId}\nAuthorization: Bearer {JWT}
activate Router

Router -> AuthMiddleware: Validate JWT
activate AuthMiddleware
AuthMiddleware --> Router: User authenticated
deactivate AuthMiddleware

Router -> Processor: ProjectProcessor.deleteProject(projectId, tokenDetails)
activate Processor

Processor -> Database: Find project with relations
activate Database
Database --> Processor: Project + data_sources + data_models
deactivate Database

Processor -> Processor: Begin transaction

loop For each data source
    Processor -> Database: Get data models for data source
    Database --> Processor: Data model list
    
    loop For each data model
        Processor -> Database: DROP TABLE schema.table_name
        note right: Physical table removal
        Database --> Processor: Table dropped
    end
    
    alt Data source is Excel schema
        Processor -> Database: DROP SCHEMA IF EXISTS dra_excel_{id}
        Database --> Processor: Schema dropped
    end
end

Processor -> Database: Delete project (cascades to data_sources, dashboards)
note right: TypeORM cascade: ["remove", "update"]
Database --> Processor: Project and related entities deleted

Processor -> Processor: Commit transaction

Processor --> Router: true (success)
deactivate Processor

Router --> Frontend: HTTP 200 OK
deactivate Router

Frontend -> Frontend: Update project list
Frontend -> Frontend: Navigate to projects page

== Data Source Creation with Encryption ==

Frontend -> Router: POST /api/data-source\nAuthorization: Bearer {JWT}\nBody: { connection_details, project_id }
activate Router

Router -> AuthMiddleware: Validate JWT
AuthMiddleware --> Router: User authenticated

Router -> Processor: DataSourceProcessor.addDataSource(connection, tokenDetails, projectId)
activate Processor

Processor -> Processor: Test connection to external database
note right: Verify credentials work

Processor -> External: Connect with credentials
activate External
External --> Processor: Connection successful
deactivate External

Processor -> Processor: Create DRADataSource entity
note right: Set connection_details field

Processor -> Database: Save data source
activate Database

Database -> Database: connectionDetailsTransformer.to()
note right: Automatic encryption via ValueTransformer\nAlgorithm: aes-256-cbc

Database -> Database: Encrypt connection_details JSON
Database -> Database: Store encrypted string in database

Database --> Processor: Data source saved with encrypted details
deactivate Database

Processor --> Router: true (success)
deactivate Processor

Router --> Frontend: HTTP 200 OK + data source ID
deactivate Router

Frontend -> Frontend: Refresh data sources list

== Data Source Retrieval with Decryption ==

Frontend -> Router: GET /api/data-source/{id}\nAuthorization: Bearer {JWT}
activate Router

Router -> Processor: DataSourceProcessor.getDataSources(tokenDetails)
activate Processor

Processor -> Database: Find data sources by user
activate Database

Database -> Database: SELECT * FROM dra_data_sources
Database -> Database: connectionDetailsTransformer.from()
note right: Automatic decryption via ValueTransformer

Database -> Database: Decrypt connection_details
Database -> Database: Parse JSON and return object

Database --> Processor: Data sources with decrypted connection_details
deactivate Database

Processor --> Router: Data source array
deactivate Processor

Router --> Frontend: HTTP 200 OK + data sources (decrypted)
deactivate Router

Frontend -> Frontend: Display data source configurations
note right: connection_details are now plain objects

== Token Validation with TokenProcessor ==

Frontend -> Router: GET /api/protected-resource\nAuthorization: Bearer {JWT}
activate Router

Router -> AuthMiddleware: Validate request
activate AuthMiddleware

AuthMiddleware -> Processor: TokenProcessor.validateToken(token)
activate Processor

Processor -> Processor: Verify JWT signature
Processor -> Processor: Check expiration time
Processor -> Processor: Validate token structure

alt Token valid
    Processor --> AuthMiddleware: true
    
    AuthMiddleware -> Processor: TokenProcessor.getTokenDetails(token)
    Processor -> Processor: Decode JWT payload
    Processor --> AuthMiddleware: { user_id, email, iat, exp }
    
    AuthMiddleware -> Database: Verify user exists
    Database --> AuthMiddleware: User found
    
    AuthMiddleware --> Router: Token valid, user context attached
    deactivate AuthMiddleware
    deactivate Processor
    
    Router -> Processor: Process business logic
    Router --> Frontend: HTTP 200 OK + data
    
else Token invalid or expired
    Processor --> AuthMiddleware: false
    deactivate Processor
    
    AuthMiddleware --> Router: HTTP 401 Unauthorized
    deactivate AuthMiddleware
    
    Router --> Frontend: HTTP 401 Unauthorized
    
    Frontend -> Frontend: Clear stored token
    Frontend -> Frontend: Redirect to login
end

deactivate Router

@enduml