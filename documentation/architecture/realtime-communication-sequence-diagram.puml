@startuml Real_Time_Communication_Sequence_Diagram
title Data Research Analysis Platform - Socket.IO Real-time Communication

participant "Frontend\n(Vue/Nuxt)" as Frontend
participant "Socket.IO Client" as SocketClient
participant "Express Server" as Express
participant "Socket.IO Server" as SocketServer
participant "Worker Thread" as Worker
participant "Queue Service" as Queue
participant "File System" as FileSystem

== Connection Establishment ==

Frontend -> SocketClient: Initialize Socket.IO connection
activate SocketClient

SocketClient -> SocketServer: Connect to ws://backend:3002
activate SocketServer

SocketServer -> Express: Share HTTP server instance
SocketServer -> Frontend: Connection established event
note right: Client receives 'connect' event

== PDF Upload Initiation ==

Frontend -> Express: POST /api/data-sources/pdf (multipart/form-data)
activate Express

Express -> FileSystem: Save uploaded PDF file
activate FileSystem
FileSystem --> Express: File saved successfully
deactivate FileSystem

Express -> Queue: Add PDF processing job
activate Queue
Queue --> Express: Job queued successfully
deactivate Queue

Express --> Frontend: HTTP 200 OK (upload complete)
deactivate Express

== Background Processing ==

Queue -> Worker: Start PDF processing job
activate Worker

Worker -> FileSystem: Read PDF file
activate FileSystem
FileSystem --> Worker: PDF file data
deactivate FileSystem

Worker -> Worker: Convert PDF to images using ghostscript
note right: Heavy processing in background thread

alt Processing Successful
    Worker -> FileSystem: Save converted images
    activate FileSystem
    FileSystem --> Worker: Images saved
    deactivate FileSystem
    
    Worker -> SocketServer: Emit 'PDF_TO_IMAGES_COMPLETE' event
    SocketServer -> SocketClient: Forward completion event
    SocketClient -> Frontend: Process completion event
    
    Frontend -> Frontend: Update UI with success message
    Frontend -> Frontend: Display converted image files
    Frontend -> Frontend: Hide progress indicators
    
else Processing Failed
    Worker -> SocketServer: Emit 'PDF_PROCESSING_ERROR' event
    SocketServer -> SocketClient: Forward error event
    SocketClient -> Frontend: Process error event
    
    Frontend -> Frontend: Display error message
    Frontend -> Frontend: Reset form state
    Frontend -> Frontend: Allow user to retry
end

deactivate Worker

== Data Model Processing ==

Frontend -> Express: POST /api/data-models/build
activate Express

Express -> Queue: Add data model building job
activate Queue
Queue --> Express: Job queued
deactivate Queue

Express --> Frontend: HTTP 200 OK
deactivate Express

Queue -> Worker: Start data model job
activate Worker

Worker -> Worker: Process data model configuration
Worker -> FileSystem: Generate SQL queries
activate FileSystem
FileSystem --> Worker: Queries saved
deactivate FileSystem

Worker -> SocketServer: Emit 'DATA_MODEL_BUILD_COMPLETE'
SocketServer -> SocketClient: Forward event with model data
SocketClient -> Frontend: Update data model state

Frontend -> Frontend: Refresh data model list
Frontend -> Frontend: Show success notification

deactivate Worker

== Dashboard Export ==

Frontend -> Express: POST /api/dashboards/export
activate Express

Express -> Queue: Add export job
activate Queue
Queue --> Express: Job queued
deactivate Queue

Express --> Frontend: HTTP 200 OK
deactivate Express

Queue -> Worker: Start export job
activate Worker

Worker -> Worker: Generate dashboard export
Worker -> FileSystem: Save export file
activate FileSystem
FileSystem --> Worker: Export file saved
deactivate FileSystem

Worker -> SocketServer: Emit 'DASHBOARD_EXPORT_COMPLETE'
SocketServer -> SocketClient: Forward event with download link
SocketClient -> Frontend: Show download ready notification

Frontend -> Frontend: Display download button
Frontend -> Frontend: Trigger file download

deactivate Worker

== Error Handling ==

alt Network Connection Lost
    SocketClient -> SocketClient: Detect disconnection
    SocketClient -> Frontend: Emit 'disconnect' event
    Frontend -> Frontend: Show "Connection lost" message
    
    SocketClient -> SocketServer: Attempt reconnection
    SocketServer -> SocketClient: Reconnection successful
    SocketClient -> Frontend: Emit 'reconnect' event
    Frontend -> Frontend: Hide connection error
    Frontend -> Frontend: Refresh current data
end

== Connection Cleanup ==

Frontend -> SocketClient: User navigates away / closes tab
SocketClient -> SocketServer: Disconnect
SocketServer -> SocketServer: Clean up client resources
deactivate SocketServer
deactivate SocketClient

== Database Backup Progress ==

Frontend -> Express: POST /admin/database/backup
activate Express
Express -> Queue: addDatabaseBackupJob(userId)
activate Queue
Queue --> Express: { jobId }
deactivate Queue
Express --> Frontend: HTTP 202 Accepted
deactivate Express

Queue -> Worker: Dequeue database backup job
activate Worker

Worker -> SocketServer: emitToUser(userId, 'backup-progress',\n{ progress: 5, message: 'Starting pg_dump...' })
activate SocketServer
SocketServer -> SocketClient: emit('backup-progress', payload)
SocketClient -> Frontend: Update backup progress bar (5%)
deactivate SocketServer

Worker -> Worker: Execute pg_dump on PostgreSQL
Worker -> SocketServer: emitToUser(userId, 'backup-progress',\n{ progress: 60, message: 'Compressing archive...' })
activate SocketServer
SocketServer -> SocketClient: emit('backup-progress', { progress: 60 })
SocketClient -> Frontend: Update backup progress bar (60%)
deactivate SocketServer

Worker -> Worker: Create ZIP archive
Worker -> SocketServer: emitToUser(userId, 'backup-progress',\n{ progress: 100, message: 'Backup complete', filename })
activate SocketServer
SocketServer -> SocketClient: emit('backup-progress', { progress: 100, filename })
SocketClient -> Frontend: Show download button
deactivate SocketServer

deactivate Worker

== Database Restore Progress ==

Frontend -> Express: POST /admin/database/restore (file upload)
activate Express
Express -> Queue: addDatabaseRestoreJob(zipPath, userId)
activate Queue
Queue --> Express: { jobId }
deactivate Queue
Express --> Frontend: HTTP 202 Accepted
deactivate Express

Queue -> Worker: Dequeue restore job
activate Worker
Worker -> SocketServer: emitToUser(userId, 'restore-progress',\n{ progress: 20, message: 'Dropping tables...' })
activate SocketServer
SocketServer -> SocketClient: emit('restore-progress', payload)
SocketClient -> Frontend: Update restore progress bar
deactivate SocketServer
Worker -> SocketServer: emitToUser(userId, 'restore-progress',\n{ progress: 100, message: 'Restore complete' })
activate SocketServer
SocketServer -> SocketClient: emit('restore-progress', { progress: 100 })
SocketClient -> Frontend: Show "Restore complete" toast
deactivate SocketServer
deactivate Worker

== Real-time Notifications ==

note over Frontend
  Any server-side action can trigger a notification
  via NotificationHelperService.createNotification()
end note

Worker -> SocketServer: emitToUser(userId, 'notification',\n{ id, type, title, message,\n  is_read: false, created_at, metadata })
activate SocketServer
SocketServer -> SocketClient: emit('notification', notificationPayload)
SocketClient -> Frontend: Receive 'notification' event
deactivate SocketServer

Frontend -> Frontend: Increment badge count
Frontend -> Frontend: Show toast: "{title}: {message}"
Frontend -> Frontend: Prepend to notification list

note over SocketServer
  **emitToUser(userId, event, payload):**
  Sends to room 'user:{userId}'
  User joins this room on socket connect
  Only reaches that specific user's connections
end note

== Google Analytics Sync Progress ==

Queue -> Worker: Dequeue GA sync job
activate Worker
Worker -> SocketServer: emitToUser(userId, 'ga-sync-progress',\n{ dataSourceId, progress: 10, message: 'Fetching GA data...' })
activate SocketServer
SocketServer -> SocketClient: emit('ga-sync-progress', payload)
SocketClient -> Frontend: Show sync progress indicator
deactivate SocketServer
Worker -> SocketServer: emitToUser(userId, 'ga-sync-progress',\n{ dataSourceId, progress: 100, message: 'Sync complete' })
activate SocketServer
SocketServer -> SocketClient: emit('ga-sync-progress', { progress: 100 })
SocketClient -> Frontend: Show "Data source updated" badge
deactivate SocketServer
deactivate Worker

note across
  **Complete Event Catalog (emitted by Backend via emitToUser):**

  | Event                  | Emitter                        | Use Case                              |
  |------------------------|--------------------------------|---------------------------------------|
  | notification           | NotificationHelperService      | Any platform-wide notification        |
  | backup-progress        | DatabaseBackupService + Worker | Real-time pg_dump & ZIP progress      |
  | restore-progress       | DatabaseBackupService + Worker | Real-time DB restore progress         |
  | PDF_TO_IMAGES_COMPLETE | WorkerService (PDF)            | PDF to image conversion done          |
  | PDF_PROCESSING_ERROR   | WorkerService (PDF)            | PDF processing failure                |
  | DATA_MODEL_BUILD_COMPLETE | WorkerService (DM)          | Data model query build finished       |
  | DASHBOARD_EXPORT_COMPLETE | WorkerService (Dashboard)   | Dashboard export file ready           |
  | ga-sync-progress       | DataSourceProcessor (GA)       | Google Analytics sync % progress      |
  | ai-response            | GeminiService                  | AI Data Modeler streaming response    |
  | query-complete         | DataModelProcessor             | Query execution result ready          |
  | dq-analysis-progress   | DataQualityProcessor           | Data quality analysis % progress      |

  **User Isolation:**
  Socket.IO rooms: user:{userId}
  Every authenticated socket joins its user room on connect
  emitToUser() broadcasts only to that room â†’ private delivery

  Socket.IO provides:
  - Automatic reconnection
  - Event acknowledgments
  - Room-based user isolation
  - Fallback to long-polling
end note

@enduml