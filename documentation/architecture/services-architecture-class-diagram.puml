@startuml Services_Architecture_Class_Diagram
!theme aws-orange
title Data Research Analysis Platform - Services Architecture

' Define styling
skinparam class {
    BackgroundColor LightBlue
    BorderColor DarkBlue
    ArrowColor DarkBlue
}
skinparam package {
    BackgroundColor LightGray
    BorderColor Gray
}

package "Core Services" {
    class UtilityService {
        -instance: UtilityService
        --
        +getInstance(): UtilityService
        +initialize(): Promise<void>
        +getDataSourceType(type: string): EDataSourceType
        +generateJWT(payload: any): string
        +verifyJWT(token: string): any
        +hashPassword(password: string): string
        +comparePassword(password: string, hash: string): boolean
        +generateUUID(): string
        +generateRandomString(length: number): string
        +sendEmail(template: string, data: any): Promise<void>
    }
    
    class EncryptionService {
        -instance: EncryptionService
        -algorithm: string
        -key: Buffer
        --
        +getInstance(): EncryptionService
        +encrypt(data: any): string
        +decrypt(encryptedData: string): any
        +isEncrypted(value: any): boolean
    }

    class QueueService {
        -instance: QueueService
        -pdfConversionQueue: Queue
        -textExtractionQueue: Queue
        --
        +getInstance(): QueueService
        +initializeQueues(): Promise<void>
        +addPDFConversionJob(fileName: string): Promise<void>
        +addTextExtractionJob(fileName: string): Promise<void>
        +getNextPDFConversionJob(): Promise<Document>
        +getNextTextExtractionJob(): Promise<Document>
        +purgeQueues(): Promise<void>
        +run(): Promise<void>
    }

    class WorkerService {
        -instance: WorkerService
        --
        +getInstance(): WorkerService
        +runWorker(operation: EOperation, fileName: string): Promise<void>
        +processJob(operation: EOperation, fileName: string): Promise<void>
    }
}

package "File Services" {
    class FilesService {
        -instance: FilesService
        --
        +getInstance(): FilesService
        +writeToFile(filePath: string, content: string): Promise<void>
        +readFile(filePath: string): Promise<string>
        +deleteFile(filePath: string): Promise<void>
        +getDirectoryPath(relativePath: string): Promise<string>
        +readDir(directoryPath: string): Promise<string[]>
        +createDirectory(directoryPath: string): Promise<void>
    }

    class PDFService {
        -instance: PDFService
        --
        +getInstance(): PDFService
        +extractPDFContent(fileName: string): Promise<any>
        +processPDFFile(filePath: string): Promise<any>
        +convertPDFToImages(fileName: string): Promise<string[]>
    }

    class ExcelFileService {
        -instance: ExcelFileService
        --
        +getInstance(): ExcelFileService
        +readExcelFile(filePath: string): Promise<any>
        +parseExcelData(data: any): Promise<any>
        +validateExcelStructure(data: any): boolean
    }
}

package "Cloud Services" {
    class AWSService {
        -instance: AWSService
        -region: string
        -s3client: S3Client
        -bucketName: string
        --
        +getInstance(): AWSService
        +initialize(region: string, bucketName: string, accessKeyId: string, secretAccessKey: string): Promise<void>
        +getRegion(): Promise<string>
        +getS3Client(): Promise<S3Client>
        +getBucketName(): Promise<string>
        +getListOfImagesFromS3Bucket(): Promise<ListObjectsCommandOutput>
        +deleteAllFilesFromS3Bucket(): Promise<void>
        +uploadFileToS3Bucket(fileName: string): Promise<void>
        +getS3Object(key: string): Promise<Uint8Array[]>
    }
}

package "Infrastructure Services" {
    class TemplateEngineService {
        -instance: TemplateEngineService
        --
        +getInstance(): TemplateEngineService
        +renderTemplate(templateName: string, data: any): Promise<string>
        +loadTemplate(templatePath: string): Promise<string>
        +compileTemplate(template: string, data: any): string
    }

    class WinstonLoggerService {
        -instance: WinstonLoggerService
        -logger: Logger
        --
        +getInstance(): WinstonLoggerService
        +info(message: string, meta?: any): void
        +error(message: string, meta?: any): void
        +warn(message: string, meta?: any): void
        +debug(message: string, meta?: any): void
    }
}

package "Data Drivers" {
    class DBDriver {
        -instance: DBDriver
        -drivers: Map<string, any>
        --
        +getInstance(): DBDriver
        +getDriver(type: string): Promise<any>
        +initialize(dataSource: DataSource): Promise<void>
        +testConnection(config: any): Promise<boolean>
    }

    class PostgresDriver {
        -instance: PostgresDriver
        -dataSource: DataSource
        --
        +getInstance(): PostgresDriver
        +initialize(dataSource: DataSource): Promise<void>
        +executeQuery(query: string): Promise<any>
        +testConnection(): Promise<boolean>
    }

    class MySQLDriver {
        -instance: MySQLDriver
        -dataSource: DataSource
        --
        +getInstance(): MySQLDriver
        +initialize(dataSource: DataSource): Promise<void>
        +executeQuery(query: string): Promise<any>
        +testConnection(): Promise<boolean>
    }

    class MariaDBDriver {
        -instance: MariaDBDriver
        -dataSource: DataSource
        --
        +getInstance(): MariaDBDriver
        +initialize(dataSource: DataSource): Promise<void>
        +executeQuery(query: string): Promise<any>
        +testConnection(): Promise<boolean>
    }
}

package "Communication Drivers" {
    class SocketIODriver {
        -instance: SocketIODriver
        -io: Server
        --
        +getInstance(): SocketIODriver
        +initialize(httpServer: HttpServer): Promise<void>
        +emit(event: string, data: any): void
        +broadcast(event: string, data: any): void
        +handleConnection(socket: Socket): void
    }

    class MailDriver {
        -instance: MailDriver
        --
        +getInstance(): MailDriver
        +sendMail(options: MailOptions): Promise<void>
        +configureTransporter(config: any): void
    }

    class NodeMailerDriver {
        -instance: NodeMailerDriver
        -transporter: Transporter
        --
        +getInstance(): NodeMailerDriver
        +initialize(config: any): Promise<void>
        +sendMail(options: MailOptions): Promise<void>
    }
}

package "Business Logic Processors" {
    class ArticleProcessor {
        -instance: ArticleProcessor
        --
        +getInstance(): ArticleProcessor
        +getArticles(tokenDetails): Promise<IArticle[]>
        +addArticle(title, content, markdown, status, categories, tokenDetails): Promise<boolean>
        +publishArticle(articleId, tokenDetails): Promise<boolean>
        +deleteArticle(articleId, tokenDetails): Promise<boolean>
        +editArticle(articleId, ...fields, tokenDetails): Promise<boolean>
        +getPublicArticles(): Promise<IArticle[]>
    }
    
    class AuthProcessor {
        -instance: AuthProcessor
        --
        +getInstance(): AuthProcessor
        +login(email, password): Promise<any>
        +register(userData): Promise<boolean>
        +verifyEmail(code): Promise<boolean>
        +forgotPassword(email): Promise<boolean>
        +resetPassword(code, newPassword): Promise<boolean>
    }
    
    class CategoryProcessor {
        -instance: CategoryProcessor
        --
        +getInstance(): CategoryProcessor
        +getCategories(tokenDetails): Promise<DRACategory[]>
        +addCategory(title, tokenDetails): Promise<boolean>
        +deleteCategory(categoryId, tokenDetails): Promise<boolean>
        +editCategory(categoryId, title, tokenDetails): Promise<boolean>
    }
    
    class DashboardProcessor {
        -instance: DashboardProcessor
        --
        +getInstance(): DashboardProcessor
        +getDashboards(tokenDetails): Promise<DRADashboard[]>
        +addDashboard(data, projectId, tokenDetails): Promise<boolean>
        +deleteDashboard(dashboardId, tokenDetails): Promise<boolean>
        +editDashboard(dashboardId, data, tokenDetails): Promise<boolean>
    }
    
    class DataModelProcessor {
        -instance: DataModelProcessor
        --
        +getInstance(): DataModelProcessor
        +getDataModels(tokenDetails): Promise<DRADataModel[]>
        +deleteDataModel(dataModelId, tokenDetails): Promise<boolean>
        +getDataModelTables(projectId, tokenDetails): Promise<any[]>
    }
    
    class DataSourceProcessor {
        -instance: DataSourceProcessor
        --
        +getInstance(): DataSourceProcessor
        +getDataSources(tokenDetails): Promise<DRADataSource[]>
        +addDataSource(connection, tokenDetails, projectId): Promise<boolean>
        +deleteDataSource(dataSourceId, tokenDetails): Promise<boolean>
        +addExcelDataSource(...): Promise<IExcelDataSourceReturn>
        +addPDFDataSource(...): Promise<IPDFDataSourceReturn>
        +addGoogleAnalyticsDataSource(connDetails, tokenDetails, projectId): Promise<boolean>
        +syncGoogleAnalyticsDataSource(dataSourceId, dateRange, tokenDetails): Promise<any>
        +addGoogleAdsDataSource(connDetails, tokenDetails, projectId): Promise<boolean>
    }
    
    class PrivateBetaUserProcessor {
        -instance: PrivateBetaUserProcessor
        --
        +getInstance(): PrivateBetaUserProcessor
        +addPrivateBetaUser(email): Promise<boolean>
        +getPrivateBetaUsers(): Promise<any[]>
        +deletePrivateBetaUser(id): Promise<boolean>
    }
    
    class ProjectProcessor {
        -instance: ProjectProcessor
        --
        +getInstance(): ProjectProcessor
        +addProject(name, description, tokenDetails): Promise<boolean>
        +getProjects(tokenDetails): Promise<DRAProject[]>
        +deleteProject(projectId, tokenDetails): Promise<boolean>
        +editProject(projectId, name, description, tokenDetails): Promise<boolean>
    }
    
    class TokenProcessor {
        -instance: TokenProcessor
        --
        +getInstance(): TokenProcessor
        +generateToken(payload): string
        +validateToken(token): boolean
        +getTokenDetails(token): ITokenDetails
    }
    
    class UserManagementProcessor {
        -instance: UserManagementProcessor
        --
        +getInstance(): UserManagementProcessor
        +getUsers(tokenDetails): Promise<any[]>
        +updateUserType(userId, userType, tokenDetails): Promise<boolean>
        +deleteUser(userId, tokenDetails): Promise<boolean>
        +updateSubscriptionTier(userId, tier): Promise<boolean>
    }
    
    class UserProcessor {
        -instance: UserProcessor
        --
        +getInstance(): UserProcessor
        +getUserProfile(tokenDetails): Promise<any>
        +updateProfile(userData, tokenDetails): Promise<boolean>
        +changePassword(oldPassword, newPassword, tokenDetails): Promise<boolean>
    }

    class NotificationProcessor {
        -instance: NotificationProcessor
        --
        +getInstance(): NotificationProcessor
        +getUserNotifications(userId, page, limit): Promise<INotification[]>
        +getUnreadCount(userId): Promise<number>
        +markAsRead(notificationId, userId): Promise<boolean>
        +markAllAsRead(userId): Promise<boolean>
        +deleteNotification(notificationId, userId): Promise<boolean>
        +cleanupExpiredNotifications(): Promise<number>
    }

    class AccountCancellationProcessor {
        -instance: AccountCancellationProcessor
        --
        +getInstance(): AccountCancellationProcessor
        +requestCancellation(userId, reason, category, feedback): Promise<any>
        +getStatus(userId): Promise<any>
        +reactivate(userId): Promise<boolean>
    }

    class AttributionProcessor {
        -instance: AttributionProcessor
        --
        +getInstance(): AttributionProcessor
        +trackEvent(projectId, eventData, userId): Promise<any>
        +generateReport(projectId, params, userId): Promise<any>
        +listProjectReports(projectId, userId): Promise<any[]>
        +getChannelPerformance(projectId, params): Promise<any>
        +calculateROI(projectId, params): Promise<any>
        +compareModels(projectId, params): Promise<any>
        +analyzeFunnel(projectId, params): Promise<any>
        +getJourneyMap(projectId, params): Promise<any>
    }

    class DataQualityProcessor {
        -instance: DataQualityProcessor
        --
        +getInstance(): DataQualityProcessor
        +analyze(dataModelId, userId, checks, options): Promise<any>
        +clean(dataModelId, userId, operations, previewOnly): Promise<any>
        +getLatestReport(dataModelId, userId): Promise<any>
        +getHistory(dataModelId, userId): Promise<any[]>
    }
}

package "OAuth & Google Integration Services" {
    class GoogleOAuthService {
        -instance: GoogleOAuthService
        -clientId: string
        -clientSecret: string
        --
        +getInstance(): GoogleOAuthService
        +isConfigured(): boolean
        +generateAuthUrl(scopes, state): string
        +exchangeCodeForTokens(code): Promise<IGoogleTokens>
        +refreshAccessToken(refreshToken): Promise<IGoogleTokens>
        +revokeToken(accessToken): Promise<void>
        +getGoogleAnalyticsScopes(): string[]
        +getGoogleAdsScopes(): string[]
        +getGoogleAdManagerScopes(): string[]
    }

    class OAuthSessionService {
        -instance: OAuthSessionService
        -redisClient: RedisClient
        --
        +getInstance(): OAuthSessionService
        +storeTokens(tokens, service, userId): Promise<string>
        +getTokens(sessionId): Promise<IGoogleTokens>
        +deleteSession(sessionId): Promise<void>
        +isSessionValid(sessionId): Promise<boolean>
    }

    class GoogleAnalyticsService {
        -instance: GoogleAnalyticsService
        --
        +getInstance(): GoogleAnalyticsService
        +listProperties(accessToken): Promise<IProperty[]>
        +getMetadata(propertyId, connectionDetails): Promise<any>
        +getReportPresets(): IReportPreset[]
        +runReport(propertyId, dateRange, dimensions, metrics, accessToken): Promise<any>
    }

    class GoogleAdsService {
        -instance: GoogleAdsService
        --
        +getInstance(): GoogleAdsService
        +listCustomers(accessToken): Promise<ICustomer[]>
        +runReport(customerId, reportType, dateRange, accessToken): Promise<any>
    }

    class GoogleAdManagerService {
        -instance: GoogleAdManagerService
        --
        +getInstance(): GoogleAdManagerService
        +listNetworks(accessToken): Promise<INetwork[]>
        +runReport(networkCode, reportType, dateRange, accessToken): Promise<any>
    }
}

package "AI Services" {
    class GeminiService {
        -instance: GeminiService
        -generativeModel: GenerativeModel
        --
        +getInstance(): GeminiService
        +initializeConversation(conversationId, systemPrompt, schemaContext): Promise<void>
        +sendMessage(conversationId, userMessage): Promise<string>
        +generateInsight(dataContext, prompt): Promise<string>
        +streamResponse(conversationId, message, onChunk): Promise<void>
    }

    class RedisAISessionService {
        -instance: RedisAISessionService
        -redisClient: RedisClient
        --
        +getInstance(): RedisAISessionService
        +createSession(dataSourceId, userId, schemaContext): Promise<string>
        +saveMessage(sessionId, role, content): Promise<void>
        +saveModelDraft(sessionId, draft): Promise<void>
        +getSession(sessionId): Promise<IAISession>
        +transferToDatabase(sessionId, dataModelId): Promise<void>
        +deleteSession(sessionId): Promise<void>
    }

    class SchemaCollectorService {
        -instance: SchemaCollectorService
        --
        +getInstance(): SchemaCollectorService
        +collectSchema(dataSource, schemaName): Promise<ITableSchema[]>
        +getTableColumns(schema, table): Promise<IColumnInfo[]>
        +getSampleData(schema, table, limit): Promise<any[]>
    }

    class SchemaFormatterService {
        +formatSchemaToMarkdown(tables): string
        +formatTableAsMarkdown(table): string
        +buildSystemPrompt(schemaMarkdown): string
    }
}

package "Project Collaboration Services" {
    class InvitationService {
        -instance: InvitationService
        --
        +getInstance(): InvitationService
        +createInvitation(projectId, email, role, invitedBy): Promise<IInvitation>
        +getProjectInvitations(projectId): Promise<IInvitation[]>
        +getUserPendingInvitations(email): Promise<IInvitation[]>
        +getInvitationByToken(token): Promise<IInvitation>
        +acceptInvitation(token, userId): Promise<any>
        +cancelInvitation(invitationId, userId): Promise<boolean>
        +resendInvitation(invitationId, userId): Promise<boolean>
        +expireOldInvitations(): Promise<number>
    }

    class RBACService {
        -instance: RBACService
        --
        +getInstance(): RBACService
        +getProjectMembers(projectId): Promise<IProjectMember[]>
        +addMember(projectId, userId, role, requesterId): Promise<boolean>
        +updateMemberRole(projectId, userId, role, requesterId): Promise<boolean>
        +removeMember(projectId, userId, requesterId): Promise<boolean>
        +getUserRole(projectId, userId): Promise<EProjectRole>
        +checkPermission(permission, role): boolean
        +authorize(permission): RequestHandler
    }

    class NotificationHelperService {
        +createNotification(userId, type, title, message, metadata, expiresAt): Promise<void>
        +bulkNotify(userIds, type, title, message): Promise<void>
    }
}

package "Data Quality Services" {
    class DataQualityExecutionService {
        -instance: DataQualityExecutionService
        --
        +getInstance(): DataQualityExecutionService
        +runChecks(dataModel, checks, options, reportId): Promise<IQualityResults>
        +runNullCheck(schema, table): Promise<INullStats[]>
        +runDuplicateCheck(schema, table): Promise<IDuplicateStats>
        +runOutlierDetection(schema, table): Promise<IOutlierStats[]>
        +runTypeConsistencyCheck(schema, table): Promise<ITypeViolation[]>
        +runReferentialIntegrityCheck(schema, table, refs): Promise<IIntegrityStats>
        +previewCleaning(dataModel, operations): Promise<ICleanPreview>
    }

    class DataQualityHistoryService {
        -instance: DataQualityHistoryService
        --
        +getInstance(): DataQualityHistoryService
        +recordHistoryEntry(dataModelId, reportId, score): Promise<void>
        +getScoreHistory(dataModelId): Promise<IHistoryPoint[]>
    }
}

package "Attribution Services" {
    class AttributionCalculatorService {
        -instance: AttributionCalculatorService
        --
        +getInstance(): AttributionCalculatorService
        +calculateAttributionModel(projectId, dateRange, model, channels): Promise<IAttributionResults>
        +applyLinearModel(paths): IChannelCredit[]
        +applyFirstTouchModel(paths): IChannelCredit[]
        +applyLastTouchModel(paths): IChannelCredit[]
        +applyTimeDecayModel(paths, halfLife): IChannelCredit[]
        +applyPositionBasedModel(paths): IChannelCredit[]
    }

    class ChannelTrackingService {
        -instance: ChannelTrackingService
        --
        +getInstance(): ChannelTrackingService
        +recordChannelTouch(projectId, sessionId, channel, timestamp, campaignId): Promise<void>
        +aggregateChannelMetrics(projectId, dateRange): Promise<IChannelMetrics[]>
    }

    class FunnelAnalysisService {
        -instance: FunnelAnalysisService
        --
        +getInstance(): FunnelAnalysisService
        +buildFunnelMetrics(projectId, funnelSteps, dateRange): Promise<IFunnelAnalysis>
        +calculateDropOffRates(steps): IDropOffRate[]
    }
}

package "Account & Billing Services" {
    class DataDeletionService {
        -instance: DataDeletionService
        --
        +getInstance(): DataDeletionService
        +estimateUserDataSize(userId): Promise<IDataSizeEstimate>
        +deleteUserData(userId): Promise<boolean>
    }

    class DataModelExportService {
        -instance: DataModelExportService
        --
        +getInstance(): DataModelExportService
        +exportDataModel(dataModelId, format, userId): Promise<IExportResult>
    }

    class TierEnforcementService {
        -instance: TierEnforcementService
        --
        +getInstance(): TierEnforcementService
        +canAccessFeature(userId, featureName): Promise<IAccessResult>
        +getUsageStats(userId): Promise<IUsageStats>
        +checkTierAccess(userId, feature): Promise<IAccessResult>
    }

    class RowLimitService {
        -instance: RowLimitService
        --
        +getInstance(): RowLimitService
        +checkRowLimitCompliance(userId, operationType): Promise<ILimitCheck>
        +getUsageStats(userId): Promise<IRowLimitStats>
        +getTierLimits(tier): ITierLimits
    }
}

package "MongoDB Services" {
    class MongoDBNativeService {
        -instance: MongoDBNativeService
        --
        +getInstance(): MongoDBNativeService
        +testConnection(connectionDetails): Promise<boolean>
        +listCollections(database): Promise<string[]>
        +inferCollectionSchema(collection, sampleSize): Promise<IInferredSchema>
        +getMongoToPGTypeMap(inferredSchema): ITypeMappings
    }

    class MongoDBImportService {
        -instance: MongoDBImportService
        --
        +getInstance(): MongoDBImportService
        +importAllCollections(dataSourceId, connectionDetails): Promise<IImportResult>
        +syncDelta(dataSourceId, connectionDetails, sinceTimestamp): Promise<ISyncResult>
    }

    class MongoDBQueryTranslator {
        -instance: MongoDBQueryTranslator
        --
        +getInstance(): MongoDBQueryTranslator
        +translateAndExecute(sql, dataModel): Promise<IQueryResults>
        +mapSchemaReferences(sql, sourceMapping): string
    }
}

package "Scheduled Jobs" {
    class ScheduledDeletionJob {
        +run(): Promise<void>
        +processExpiredCancellations(): Promise<void>
        +sendWarningEmails(daysRemaining): Promise<void>
    }

    class ScheduledBackupJob {
        +run(): Promise<void>
        +triggerAutomatedBackup(): Promise<void>
    }
}



package "Text Processing" {
    class TextExtractDriver {
        -instance: TextExtractDriver
        --
        +getInstance(): TextExtractDriver
        +extractTextFromImage(imagePath: string): Promise<string>
        +processTextData(text: string): Promise<any>
    }

    class AmazonTextExtractDriver {
        -instance: AmazonTextExtractDriver
        -textractClient: TextractClient
        --
        +getInstance(): AmazonTextExtractDriver
        +initialize(region: string, credentials: any): Promise<void>
        +extractTextFromImage(imageBuffer: Buffer): Promise<any>
        +analyzeDocument(document: any): Promise<any>
    }
}

' Service Dependencies
UtilityService --> DBDriver : uses
UtilityService --> QueueService : initializes
UtilityService --> SocketIODriver : configures
UtilityService --> EncryptionService : uses for JWT

QueueService --> WorkerService : processes jobs
WorkerService --> FilesService : manages files
WorkerService --> SocketIODriver : emits events
WorkerService --> PDFService : processes PDFs

PDFService --> FilesService : reads/writes files
PDFService --> QueueService : queues jobs

' Processor Dependencies
ArticleProcessor --> DBDriver : queries
ArticleProcessor --> EncryptionService : uses
AuthProcessor --> DBDriver : queries
AuthProcessor --> TokenProcessor : generates tokens
AuthProcessor --> UtilityService : password hashing
CategoryProcessor --> DBDriver : queries
DashboardProcessor --> DBDriver : queries
DataModelProcessor --> DBDriver : queries
DataSourceProcessor --> DBDriver : manages connections
DataSourceProcessor --> EncryptionService : encrypts connection details
DataSourceProcessor --> UtilityService : utilities
DataSourceProcessor --> QueueService : file operations
DataSourceProcessor --> FilesService : file management
DataSourceProcessor --> ExcelFileService : Excel processing
DataSourceProcessor --> PDFService : PDF processing
PrivateBetaUserProcessor --> DBDriver : queries
ProjectProcessor --> DBDriver : queries
ProjectProcessor --> DataSourceProcessor : cascade deletes
TokenProcessor --> UtilityService : JWT operations
UserManagementProcessor --> DBDriver : queries
UserProcessor --> DBDriver : queries
UserProcessor --> UtilityService : password operations

' New Processor Dependencies
NotificationProcessor --> DBDriver : queries
AccountCancellationProcessor --> DBDriver : queries
AccountCancellationProcessor --> NotificationHelperService : notifies
AccountCancellationProcessor --> DataDeletionService : delegates deletion
AttributionProcessor --> AttributionCalculatorService : calculates
AttributionProcessor --> ChannelTrackingService : tracks
AttributionProcessor --> FunnelAnalysisService : analyzes
AttributionProcessor --> DBDriver : stores results
DataQualityProcessor --> DataQualityExecutionService : runs checks
DataQualityProcessor --> DataQualityHistoryService : records history
DataQualityProcessor --> NotificationHelperService : notifies
DataQualityProcessor --> SocketIODriver : progress events

' Google OAuth Dependencies
GoogleOAuthService ..> Google : "Google Auth APIs"
OAuthSessionService --> RedisClient : "stores tokens"
DataSourceProcessor --> GoogleOAuthService : refreshes tokens
DataSourceProcessor --> GoogleAnalyticsService : fetches data
DataSourceProcessor --> GoogleAdsService : fetches ads data

' AI Service Dependencies
GeminiService ..> GoogleGeminiAPI : "Gemini 2.0 Flash"
RedisAISessionService --> RedisClient : "24h TTL sessions"
DataModelProcessor --> GeminiService : sends prompts
DataModelProcessor --> RedisAISessionService : manages sessions
DataModelProcessor --> SchemaCollectorService : collects schema
SchemaCollectorService --> DBDriver : queries schema
SchemaFormatterService ..> SchemaCollectorService : formats output

' Collaboration Service Dependencies
InvitationService --> DBDriver : queries
InvitationService --> NotificationHelperService : notifies
InvitationService --> MailDriver : sends emails
RBACService --> DBDriver : queries
RBACService --> NotificationHelperService : notifies
NotificationHelperService --> SocketIODriver : emits real-time
NotificationHelperService --> DBDriver : persists

' MongoDB Dependencies
DataSourceProcessor --> MongoDBNativeService : connects
DataSourceProcessor --> MongoDBImportService : imports
MongoDBNativeService ..> MongoDB : "MongoDB driver"
MongoDBImportService --> MongoDBNativeService : uses
MongoDBQueryTranslator --> DBDriver : executes SQL

' Tier / Billing Dependencies
TierEnforcementService --> DBDriver : checks tier
RowLimitService --> DBDriver : counts rows

' Data Operations
DatabaseBackupService --> SocketIODriver : emits progress
DatabaseBackupService --> NotificationHelperService : notifies
DatabaseBackupService ..> pgdump : "pg_dump/psql system commands"
DataDeletionService --> DBDriver : cascade deletes
DataModelExportService --> FilesService : writes exports

' Scheduled Jobs
ScheduledDeletionJob --> DataDeletionService : triggers deletion
ScheduledDeletionJob --> MailDriver : sends warnings
ScheduledBackupJob --> QueueService : queues backup jobs

AWSService --> FilesService : uploads files
AWSService ..> TextExtractDriver : may use

DBDriver --> PostgresDriver : manages
DBDriver --> MySQLDriver : manages
DBDriver --> MariaDBDriver : manages

MailDriver --> NodeMailerDriver : implements
UtilityService --> MailDriver : sends emails
UtilityService --> TemplateEngineService : renders templates

TextExtractDriver <|-- AmazonTextExtractDriver : extends
AmazonTextExtractDriver --> AWSService : uses AWS services

WorkerService --> TextExtractDriver : processes text
PDFService --> AWSService : may upload to S3

' All services use logging
UtilityService ..> WinstonLoggerService : logs
QueueService ..> WinstonLoggerService : logs
WorkerService ..> WinstonLoggerService : logs
PDFService ..> WinstonLoggerService : logs
DataSourceProcessor ..> WinstonLoggerService : logs

note right of QueueService : Manages background job processing\nfor PDF conversion, text extraction,\ndatabase backup, and restore

note right of WorkerService : Spawns worker threads for\nheavy processing tasks

note right of SocketIODriver : emitToUser(userId, event, payload)\nUser rooms: 'user:{userId}'\nAll processors can emit events

note right of DataSourceProcessor : Handles Excel/PDF/MongoDB/Google data\nwith table creation and management\nUses EncryptionService for connection_details

note bottom of AWSService : Handles S3 operations for\nfile storage and retrieval

note left of ArticleProcessor : **All Processors Follow Singleton Pattern:**\n- Private constructor\n- Static getInstance() method\n- Single instance per application

note right of EncryptionService : **Encryption Details:**\nAlgorithm: aes-256-cbc\nAutomatic encryption/decryption\nvia TypeORM ValueTransformer\nSupports legacy unencrypted data

note bottom of TokenProcessor : **JWT Token Management:**\nGenerates tokens with user payload\nValidates token signature & expiration\nExtracts token details for authentication

note top of ProjectProcessor : **Cascade Deletion:**\nProject deletion triggers:\n- Data source removal\n- Data model table drops\n- Dashboard cleanup\n- All via cascade relationships

note right of GeminiService : **AI Model:**\nGoogle Gemini 2.0 Flash\nConversation history in Redis (24h TTL)\nSchema fed as markdown system context\nStructured 3-section response format

note right of RBACService : **RBAC Permissions:**\nOWNER > EDITOR > VIEWER\nauthrize() middleware guard\nChecked per-route on project operations

@enduml